---
title: "Iteration and List Columns"
output: github_document
date: "2022-11-01"
---

```{r setup, include = FALSE}
library(tidyverse)
set.seed(1)

knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

## Lists

In R, vectors are limited to a single data class â€“ all elements are characters, or all numeric, or all logical. Trying to join the following vectors will result in coersion, as would creating vectors of mixed types.

```{r}
vec_numeric = 5:8
vec_char = c("My", "name", "is", "Jeff")
vec_logical = c(TRUE, TRUE, TRUE, FALSE)
```

Lists contain indexed elements, and the indexed elements themselves be scalars, vectors, or other things entirely.

```{r}
l = list(
  vec_numeric = 5:8,
  mat         = matrix(1:8, 2, 4),
  vec_logical = c(TRUE, FALSE),
  summary     = summary(rnorm(1000)))
l
```

### Accessing list items

Lists can be accessed using names or indices, and the things in lists can be accessed in the way you would usually access an object of that type. DO NOT USE DOLLAR SIGNS IN YOUR CODE!

```{r}
l$vec_numeric

l[[1]]

l[[1]][1:3]

l[["mat"]]
```

## For loops

Let's write a for loop to take the mean and SD of four samples from a normal distribution.


```{r}
list_norms = 
  list(
    a = rnorm(20, 5, 4),
    b = rnorm(20, -12, 3),
    c = rnorm(20, 17, .4),
    d = rnorm(20, 100, 1)
  )

is.list(list_norms)
```

Here's my function:

```{r}
mean_and_sd = function(x) {
  
  if (!is.numeric(x)) {
    stop("Argument x should be numeric")
  } else if (length(x) == 1) {
    stop("Cannot be computed for length 1 vectors")
  }
  
  mean_x = mean(x)
  sd_x = sd(x)

  tibble(
    mean = mean_x, 
    sd = sd_x
  )
}
```

Let's try to make this work:

```{r}
mean_and_sd(list_norms[[1]])
mean_and_sd(list_norms[[2]])
mean_and_sd(list_norms[[3]])
```
This is not very concise. Let's try a `for` loop instead!

```{r}

```

